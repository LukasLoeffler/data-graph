import { connect } from 'mqtt';
import { NodeManager } from "../node-manager";
import { MqttServerConnection, MqttServerManager } from "../../manager/mqtt-manager";
import { BaseNode } from "../base-node";
import chalk from "chalk";



const NODE_TYPE = "MQTT_PUB"

let requiredOptions = ["Server, Topic"];

export class MqttBaseNode extends BaseNode {
    options: any;
    server: MqttServerConnection;
    topic: string;
    client: any;

    constructor(name: string, id: string, options: any, targetsSuccess: any) {
        super(name, NODE_TYPE, id, targetsSuccess, []);
        console.log(options);
        //this.validateOptions(options);
        this.options = options;
        this.server = MqttServerManager.getServerById(this.getOption("Server")); 
        this.topic = this.getOption("Topic");
        this.createClient();
        NodeManager.addNode(this);
    }


    createClient() {
        this.client = connect(this.server.url);
        this.client.on('connect', () => {
            console.log(`MQTT ${this.server}: ${chalk.greenBright("connected")}`);
        })
    }


    /**
     * Options are generated by the frontend end therefore a source for errors.
     * This method checks the passed options of the constructor against the requiredOptions of this class.
     * @param options Passed options
     */
    validateOptions(options: any) {
        requiredOptions.forEach(option => {
            console.log(options);
            let checkedOption = options[option];
            if (!checkedOption) throw new Error(`${chalk.red(NODE_TYPE)}: Option '${option}' is not present`);
        });
    }


    /**
     * Extracts the optionValue for optionName
     * @param options 
     */
    getOption(optionName: string) {
        return this.options[optionName];
    }

    /**
     * Will be executed on reset and end the client.
     * Otherwise old subscriptions are still active.
     */
    stop() {
        this.client.end();
    }
}